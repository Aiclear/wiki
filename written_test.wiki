
== rand() ==
# 10.0*rand()/(RAND_MAX+1.0)
  产生[0~10)之间的浮点数
# (int)10.0*rand()/(RAND_MAX+1.0) 产生[0~9]整数，比rand()%10产生的[0~9]整数要均匀
  在多次随机出来的结果，前者理论上会更平均，而后者仅仅是和10求余得到的结果，没前面的结果来得平均

== 概率问题 ==
== 内存字节对齐问题 ==
sizof详解http://www.cnblogs.com/wangkangluo1/archive/2011/09/27/2193072.html

struct st1
{
    char a;
    char a1;
    double b;
};
sizeof(struct st1) = 12
struct st2
{
    double a;
    char c;
};
sizeof(struct st2) = 12;
sizeof("ab") = 3; strlen("ab") = 2;
== 排序算法 ==
下列排序算法中，初始数据集的排序程序对算法性能无影响的是（）
A，插入排序B，堆排序 C，冒泡排序，D，快速排序
答案：B，冒泡的复杂度恒定为O(n^2)，插入排序最差是O(n^2)，最优化为O(n);堆排序建堆的时间是O(n)，但是，排序的过程是O(nlogn)，固定不变;
冒泡排序虽然大家都认为是O(n^2)，但是，优化的冒泡是使用一个flag的，如果flag不变，说明不需要 再交换元素了,最优可以到O(n)，快速排序不解释，最差的情况每一次只分出一个元素，最差是O(n^2)，最优的时候是O(nlogn)
== 带环单链表 ==
1. 要判断出一个单链表中是否有环需要几个指针(2个，有环的话两个指针同时跑一快一慢，快的肯定会追上慢的)
2. 找出带环单链表中交叉点位置（m = n1 + n2; 两指针第一次相遇后开始计数，第二次相遇即为环的大小m,此时将相遇点断开.让一个指针从表头开始跑，跑到末尾处计数为n,则n = n1 + n2）
== 搜索算法 ==
== cache问题 ==
Cache一般比较小，但是，速度会更快，CPU内的Cache容量显然小于CPU外的，其设计原理是利用程序的局部性原理，即一断数据现在被访问，可能一会又会被访问，目标是提高数据的访问速度，其`命中率的关键因素`与`替换算法`有关系，而不是替换算法的复杂度
== 宏 ==
# do{}while(0)
# #ifndef xxx_H 避免重复包含头文件
== 数据库范式 ==
== 数据库基本操作 ==
== 循环队列 ==
== 可剥夺式进程调度方案，计算CPU利用率 ==
在一个单CPU的计算机系统中，有两台外部设备R1、R2和三个进程P1、P2、P3。系统采用可剥夺式优先级的进程调度方案，且所有进程可以并行使用I/O设备，三个进程的优先级、使用设备的先后顺序和占用设备的间如下表所示：

进程  优先级  使用设备的先后顺序和占用设备时间
P1  高  R2(30ms)→CPU(10ms) → R1(30ms) →CPU(10ms)
P2  中  R1(20ms)→CPU(30ms) →R2(40ms)
P3  低  CPU (40ms)→R1(10ms)

假设操作系统的开销忽略不计，三个进程从投入运行到全部完成，CPU的利用率约为_____(26)____% ；R2的利用率约为_____(27)____% （设备的利用率指该设备的使用时间与进程组全部完成所占用时间的比率）。

R1  (20msP2)                      (20msP1)  (10msP1)                      (10msP3)
R2  (20msP1)  (10msP1)                      (10msP2)  (10msP2)  (10msP2)  (10msP2)
Cpu (20msP3)  (10msP2)  (10msP1)  (20msP2)  (10msP3)  (10msP1)  (10msP3)

CPU          90/100
R2           70/100
== 智力题 ==
有A、B、C、D四个人，要在夜里过一座桥。他们通过这座桥分别需要耗时1、2、5、10分钟，只有一支手电，并且同时最多只能两个人一起过桥。请问，如何安排，能够在17分钟内这四个人都过桥？
第一趟过去：两人：花1分钟和2分钟的人  //总共耗时：2分钟
第一趟过来：一人：花1分钟的人         //总共耗时：3分钟
第二趟过去：两人：花5分钟和10分钟的人 //总共耗时：13分钟
第二趟过来：一人：花2分钟的人         //总共耗时：15分钟
第三趟过去：两人：花1分钟和2分钟的人 //总共耗时：17分钟
考虑田忌赛马（大带大，并行消耗时间）
== 大数相乘 ==
http://www.itmian4.com/forum.php?mod=viewthread&tid=4360&highlight=%CC%DA%D1%B6
== 字节概念和指针操作 ==
# a = (int)((int *)0 + 4); //a 的值为多少
# {{{ cpp
    int a[5] = {1, 2, 3, 4, 5};
    int *ptr = (int *)(&a +1);
    printf("%d, %d\n", *(a + 1), *(ptr - 1));
    }}}
    输出什么?(*(a+1)其实很简单就是指a[1],输出为2; &a+1不是首地址+1，系统会认为加了一个整个a数组，偏移了整个数组a的大小（也就是5个int的大小）。所以int *ptr=(int *)(&a+1);其实ptr实际是&(a[5]),也就是a+5.&a是数组指针，其类型为int(*)[5])
== extern "C" ==
http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html
== 下标为什么从0开始 ==
http://wangcong.org/blog/archives/2230
http://bigtang.org/?p=97
当处理长度为 N 的序列时,坚持 a) 的方式，当下标从1开始时，下标范围为 1<= i < N+1；当下标从0开始时则是更好看的 0<= i < N(上界直接是序列长度)
